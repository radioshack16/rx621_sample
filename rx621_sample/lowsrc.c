/***********************************************************************/
/*                                                                     */
/*  FILE        :lowsrc.c                                              */
/*  DATE        :Sat, May 07, 2016                                     */
/*  DESCRIPTION :Program of I/O Stream                                 */
/*  CPU TYPE    :RX62N                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/
/*********************************************************************
*
* Device     : RX
*
* File Name  : lowsrc.c
*
* Abstract   : Program of I/O Stream.
*
* History    : 1.00  (2009-08-07)
*
* NOTE       : THIS IS A TYPICAL EXAMPLE.
*
* Copyright (C) 2009 Renesas Electronics Corporation.
* and Renesas Solutions Corporation. All rights reserved.
*
*********************************************************************/

#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include "lowsrc.h"

/* ファイル番号 */
#define STDIN  0                    /* 標準入力           (コンソール) */
#define STDOUT 1                    /* 標準出力           (コンソール) */
#define STDERR 2                    /* 標準エラー出力     (コンソール) */

#define FLMIN  0                    /* 最小のファイル番号              */
#define _MOPENR	0x1
#define _MOPENW	0x2
#define _MOPENA	0x4
#define _MTRUNC	0x8
#define _MCREAT	0x10
#define _MBIN	0x20
#define _MEXCL	0x40
#define _MALBUF	0x40
#define _MALFIL	0x80
#define _MEOF	0x100
#define _MERR	0x200
#define _MLBF	0x400
#define _MNBF	0x800
#define _MREAD	0x1000
#define _MWRITE	0x2000
#define _MBYTE	0x4000
#define _MWIDE	0x8000
/* ファイルフラグ */
#define O_RDONLY 0x0001 /* 読み込み専用にオープン                      */
#define O_WRONLY 0x0002 /* 書き出し専用にオープン                      */
#define O_RDWR   0x0004 /* 読み書き、両用にオープン                    */
#define O_CREAT  0x0008 /* ファイルが存在しない場合、新規作成          */
#define O_TRUNC  0x0010 /* ファイルが存在する場合、ファイルサイズを0に */
#define O_APPEND 0x0020 /* 次に読み書きを行うファイル内の位置を設定    */
                        /* 0：ファイルの先頭  1：ファイルの最後        */

/* 特殊文字コード */
#define CR 0x0d                     /* 復帰                            */
#define LF 0x0a                     /* 改行                            */

extern const long _nfiles;     /* 入出力ファイル数を指定               */
char flmod[IOSTREAM];          /* オープンしたファイルのモード設定場所 */

unsigned char sml_buf[IOSTREAM];

#define FPATH_STDIN     "C:\\stdin"
#define FPATH_STDOUT    "C:\\stdout"
#define FPATH_STDERR    "C:\\stderr"

/* 標準入力からの1文字入力処理 */
extern void charput(unsigned char);
/* 標準出力への1文字出力処理 */
extern unsigned char charget(void);

#include <stdio.h>
FILE *_Files[IOSTREAM]; // ファイル構造体
char *env_list[] = { //環境変数文字列配列(**environ)
    "ENV1=temp01",
    "ENV2=temp02",
    "ENV9=end",
    '\0'            // 環境変数配列終端NULL
};

char **environ = env_list;

/****************************************************************************/
/* _INIT_IOLIB                                                              */
/*  Initialize C library Functions, if necessary.                           */
/*  Define USES_SIMIO on Assembler Option.                                  */
/****************************************************************************/
void _INIT_IOLIB( void )
{
    /* 標準入出力用ファイルをオープン、または生成します。各FILE構造体の     */
    /* 初期化はライブラリ内で行っています。各ファイル構造体の_Bufメンバに   */
    /* freopen()によってリセットされたバッファ最終ポインタを再設定します。  */

    /* 標準入力用ファイル                                                   */
    if( freopen( FPATH_STDIN, "r", stdin ) == NULL )
        stdin->_Mode = 0xffff;          /* オープン失敗時のアクセス禁止     */
    stdin->_Mode  = _MOPENR;            /* ファイルを読み込み専用に設定     */
    stdin->_Mode |= _MNBF;              /* データのバッファリングなしに設定 */
    stdin->_Bend = stdin->_Buf + 1;     /* バッファ最終ポインタの再設定     */

    /* 標準出力用ファイル                                                   */
    if( freopen( FPATH_STDOUT, "w", stdout ) == NULL ) 
        stdout->_Mode = 0xffff;         /* オープン失敗時のアクセス禁止     */
    stdout->_Mode |= _MNBF;             /* データのバッファリングなしに設定 */
    stdout->_Bend = stdout->_Buf + 1;   /* バッファ最終ポインタの再設定     */
    
    /* 標準エラー出力用ファイル                                             */
    if( freopen( FPATH_STDERR, "w", stderr ) == NULL )
        stderr->_Mode = 0xffff;         /* オープン失敗時のアクセス禁止     */
    stderr->_Mode |= _MNBF;             /* データのバッファリングなしに設定 */
    stderr->_Bend = stderr->_Buf + 1;   /* バッファ最終ポインタの再設定     */
}

/****************************************************************************/
/* _CLOSEALL                                                                */
/****************************************************************************/
void _CLOSEALL( void )
{
    long i;

    for( i=0; i < _nfiles; i++ )
    {
        /* ファイルがオープンしているかチェック                              */
        if( _Files[i]->_Mode & (_MOPENR | _MOPENW | _MOPENA ) )
        fclose( _Files[i] );    /* ファイルをクローズする                    */
    }
}

/**************************************************************************/
/*       open:file open                                                   */
/*          Return value:File number (Pass)                               */
/*                       -1          (Failure)                            */
/**************************************************************************/
long open(const char *name,               /* ファイル名                   */
     long  mode,                          /* オープンモード               */
     long  flg)                           /* オープンフラグ               */
{

   
    if( strcmp( name, FPATH_STDIN ) == 0 )      /* 標準入力ファイル       */
    {
        if( ( mode & O_RDONLY ) == 0 ) return -1;
        flmod[STDIN] = mode;
        return STDIN;
    }
    else if( strcmp( name, FPATH_STDOUT ) == 0 )/* 標準出力ファイル       */
    {
        if( ( mode & O_WRONLY ) == 0 ) return -1;
        flmod[STDOUT] = mode;
        return STDOUT;
    }
    else if(strcmp(name, FPATH_STDERR ) == 0 )  /* 標準エラー出力ファイル */
    {
        if( ( mode & O_WRONLY ) == 0 ) return -1;
        flmod[STDERR] = mode;
        return STDERR;
    }
    else return -1;                             /*標準入出力以外のファイル*/
}

long close( long fileno )
{
    return 1;
}

/**************************************************************************/
/* write:Data write                                                       */
/*  Return value:Number of write characters (Pass)                        */
/*               -1                         (Failure)                     */
/**************************************************************************/
long write(long  fileno,                  /* ファイル番号                 */
      const unsigned char *buf,           /* 転送先バッファアドレス       */
      long  count)                        /* 書き出し文字数               */
{
    long    i;                           /* カウント用変数                */
    unsigned char    c;                  /* 出力文字                      */

    /* ファイルのモードをチェックし、一文字づつ出力                       */
    /* 書き出し専用 or 読み込み書き出し両用にオープンされているか判定     */
    if(flmod[fileno]&O_WRONLY || flmod[fileno]&O_RDWR)
    {
        if( fileno == STDIN ) return -1;            /* 標準入力           */
        else if( (fileno == STDOUT) || (fileno == STDERR) ) /* 標準出力   */
        {
            for( i = count; i > 0; --i )
            {
                c = *buf++;
                charput(c);
            }
            return count;                /* 書き出した文字数返却。        */
        }
        else return -1;                  /* ファイル出力                  */
    }
    else return -1;                      /* エラー                        */
}

long read( long fileno, unsigned char *buf, long count )
{
	   long i;

       /* ファイル番号に従ってモードをチェックし、一文字づつ入力してバッファに格納 */

       if((flmod[fileno]&_MOPENR) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0; i--){
                   *buf = charget();
                   if(*buf==CR){              /* 改行文字の置き換え */
                         *buf = LF;
                   }
                   buf++;
             }
             return count;
       }
       else {
             return -1;
       }
}

long lseek( long fileno, long offset, long base )
{
    return -1L;
}

